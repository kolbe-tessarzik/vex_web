<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>VEX IQ BLE Control</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }

    button,
    select {
      font-size: 1rem;
      margin: 5px;
      padding: 10px 15px;
    }

    #stdout {
      white-space: pre;
      border: 1px solid #ccc;
      background: #111;
      color: rgb(255, 255, 255);
      padding: 10px;
      height: 400px;
      overflow-y: scroll;
      font-family: monospace;
    }

    #log {
      border: 1px solid #ccc;
      background: #111;
      color: #0f0;
      padding: 10px;
      height: 200px;
      overflow-y: scroll;
      font-family: monospace;
    }

    #structured {
      white-space: pre;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 2px;
      /* space between rows */
    }

    .row {
      display: flex;
      gap: 2px;
      /* space between buttons */
      align-items: center;
    }

    .folder-icon {
      width: 36px;
      height: 36px;
      pointer-events: none;
    }

    /* Dimmed background */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1010;
    }

    /* Modal box */
    .modal {
      width: 480px;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    /* Header */
    .modal-header {
      background: #e5e6e9;
      padding: 20px;
      font-size: 24px;
      font-weight: 600;
      text-align: center;
    }

    /* Body */
    .modal-body {
      padding: 30px;
      font-size: 20px;
      text-align: center;
    }

    .modal-body input {
      width: 80%;
      font-size: 24px;
      padding: 12px;
      margin-top: 20px;
      border-radius: 8px;
      border: 2px solid #ccc;
      outline: none;
      text-align: center;
    }

    .invalid {
      background: #ff8a3d;
      /* the orange fill */
      border-color: #0057ff;
      /* bright blue outline */
      border-width: 3px;
    }

    .modal-body input:focus {
      border-color: #6ba5ff;
    }

    /* Footer */
    .modal-footer {
      padding: 20px;
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    .btn {
      font-size: 18px;
      padding: 10px 22px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
    }

    button .icon {
      fill: black;
      /* whatever color you want for enabled */
      transition: fill 0.2s;
    }

    /* Icon color when button is disabled */
    button:disabled .icon {
      fill: rgb(188, 188, 188);
      /* grayed-out color */
    }


    .btn-cancel {
      background: #5b6168;
      color: white;
    }

    .btn-submit {
      background: #a8c5ff;
      color: white;
    }

    .btn-submit.enabled {
      background: #6ba5ff;
    }

    #snapshot {
      position: fixed;
      top: 20px;
      /* Distance from the top edge of the browser window */
      left: 20px;
      /* Distance from the right edge of the browser window */
      /* optional: add z-index to ensure it stays on top of other elements */
      z-index: 1000;

    }

    #canvasButton {
      position: fixed;
      top: 20px;
      /* Distance from the top edge of the browser window */
      right: 20px;
      /* Distance from the right edge of the browser window */
      /* optional: add z-index to ensure it stays on top of other elements */
      z-index: 1000;
    }

    /* Dim overlay */
    #overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 10;
    }

    /* Chart container */
    #chartContainer {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: calc(100vw - 90px);
      height: calc(100vh - 130px);
      border: 1px solid black;
      background-color: white;
      z-index: 20;
    }

    canvas {
      width: 100%;
      height: 100%;
    }

    /* =========================
      Wrapper (full-screen)
      ========================= */
    .ble-progress-wrapper {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;

      display: flex;
      align-items: center;
      justify-content: center;

      z-index: 9999;
      pointer-events: auto;
    }

    /* Full-screen flash overlay */
    .ble-progress-wrapper::after {
      content: "";
      position: absolute;
      inset: 0;
      background: rgba(229, 83, 61, 0);
      pointer-events: none;
      z-index: 1;
    }

    @keyframes ble-screen-flash {
      0%   { background: rgba(229, 83, 61, 0); }
      20%  { background: rgba(229, 83, 61, 0.85); } /* much stronger */
      100% { background: rgba(229, 83, 61, 0); }
    }

    .ble-progress-wrapper.flash-error::after {
      animation: ble-screen-flash 320ms ease-out;
    }

    .ble-progress-wrapper.hidden {
      display: none;
      pointer-events: none;
    }

    /* =========================
      Card
      ========================= */
    .ble-progress {
      position: relative;
      z-index: 2;

      width: 520px;
      padding: 28px 32px 32px;
      border-radius: 16px;

      background: #ffffff;
      box-shadow:
        0 12px 32px rgba(0, 0, 0, 0.12),
        0 2px 6px rgba(0, 0, 0, 0.08);

      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    /* =========================
      Header
      ========================= */
    .ble-progress-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 14px;
    }

    .ble-status {
      font-size: 18px;
      font-weight: 600;
      color: #222;
    }

    .ble-percent {
      font-size: 16px;
      font-weight: 500;
      color: #555;
      font-variant-numeric: tabular-nums;
    }

    /* =========================
      Progress bar
      ========================= */
    .ble-progress-track {
      height: 16px;
      background: #e6e8eb;
      border-radius: 999px;
      overflow: hidden;
    }

    .ble-progress-fill {
      height: 100%;
      width: 0%;
      border-radius: 999px;

      background: linear-gradient(90deg, #4f8cff, #6bb7ff);
      transition: width 300ms ease-out;
    }

    /* =========================
      States
      ========================= */
    .ble-progress.complete .ble-progress-fill {
      background: linear-gradient(90deg, #2eb872, #6fe3a1);
    }

    .ble-progress.error .ble-progress-fill {
      background: linear-gradient(
        90deg,
        #d63b2f 0%,
        #e5533d 45%,
        #ff8a75 100%
      );
    }

    .ble-progress.error .ble-progress-track {
      background: linear-gradient(180deg, #f6d2cd, #f2c1bb);
    }

    /* Freeze motion on failure */
    .ble-progress.frozen .ble-progress-fill {
      transition: none;
    }

    table {
        border-collapse: collapse;
        width: 800px;
        font-family: sans-serif;
    }

    th,
    td {
        padding: 8px 10px;
        border-bottom: 1px solid #ddd;
        text-align: left;
    }

    th {
        background: #f4f4f4;
        font-weight: 600;
    }

    /* select element removed — using custom Dropdown. Keep legacy rule for other selects */
    select {
        width: 100%;
    }

    /* align remove button and picker inline */
    .name-cell {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .name-cell .custom-select {
        flex: 1 1 auto;
        width: 100%;
    }

    .empty {
        color: #aaa;
    }

    .remove-btn,
    .action-btn,
    .slot-btn,
    .openFolder-btn {
        border-radius: 8px;
        margin-right: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    /* Remove button is just the circular SVG. Make the hit area exactly the circle
        by clipping to a circle and sizing the button to the SVG (20x20). */
    .remove-btn {
        background: transparent;
        border: none;
        padding: 0;
        width: 40px;
        height: 40px;
        min-width: 40px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        /* clip the clickable area to the circular shape */
        -webkit-clip-path: circle(50% at 50% 50%);
        clip-path: circle(50% at 50% 50%);
        cursor: pointer;
        transition: transform 0.08s ease, opacity 0.08s ease;
    }

    .remove-btn:hover {
        transform: scale(1.04);
    }

    /* keep a visible focus style for keyboard users (circular outline) */
    .remove-btn:focus {
        outline: 2px solid rgba(217, 83, 79, 0.5);
        outline-offset: 3px;
        border-radius: 50%;
    }

    /* action buttons: square, light gray background, icon and label colored via --icon-color */
    .action-btn, .slot-btn, .openFolder-btn {
        background: #f5f5f5;
        border: 1px solid #ddd;
        color: #333;
        /* fallback for icon/text color */
        width: 40px;
        height: 40px;
        padding: 3px 4px;
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 2px;
        border-radius: 6px;
        box-sizing: border-box;
    }

    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); } /* resting */
      40% { transform: translateY(-15px); }
      60% { transform: translateY(-8px); }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20%, 60% { transform: translateX(-5px); }
      40%, 80% { transform: translateX(5px); }
    }


    /* When button B is hovered AND disabled, make button A bounce */
    .bounce {
      animation: bounce 0.6s infinite;
    }

    .bounce-slow {
      animation: bounce 1.2s infinite;
    }

    .shake {
      animation: shake 0.4s;
    }

    .action-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .action-btn.run {
        --icon-color: #4CAF50;
    }

    .action-btn.stop {
        --icon-color: #e55353;
    }

    .action-btn.download {
        --icon-color: #2d7ef7;
    }

    .action-btn svg {
        width: 12px;
        height: 12px;
        display: block;
        color: var(--icon-color);
    }

    .action-btn.download svg {
        width: 20px;
        height: 20px;
        transform: translateY(1px);
    }

    .action-btn .btn-label {
        font-size: 9px;
        font-weight: 700;
        text-transform: uppercase;
        line-height: 1;
        color: var(--icon-color);
        text-align: center
    }

    .action-btn .btn-label span {
        display: block
    }

    /* svg icons inside action buttons: inherit button color and size */
    .action-btn svg {
        width: 16px;
        height: 16px;
        display: inline-block;
        vertical-align: middle;
    }

    /* Dropdown select styling to match control heights */
    .custom-select .select-selected {
        height: 40px;
        padding: 0 8px;
        display: flex;
        align-items: center;
    }

    .custom-select .large-text {
        font-size: 14px;
        font-weight: 600
    }

    .custom-select .small-text {
        font-size: 11px;
        color: #777
    }

    .hidden {
        visibility: hidden;
    }

    .no_display {
        display: none;
    }

    /* placeholder state: reserve layout space but keep the control visually absent
        and non-interactive until its inner content slides in */
    .control-placeholder {
        background: transparent !important;
        border-color: transparent !important;
        pointer-events: none;
    }

    /* animate-in helpers for controls */
    :root { --ctrl-size: 40px; --ctrl-gap: 8px; }
    .action-btn, .slot-btn, .remove-btn {
        will-change: width, margin;
        box-sizing: border-box;
        width: var(--ctrl-size);
        min-width: var(--ctrl-size);
        padding: 3px 4px;
        margin-right: var(--ctrl-gap);
        transition: width 260ms cubic-bezier(.2,.9,.2,1), margin 200ms ease;
        overflow: hidden;
    }

    /* collapsed state: zero width so the control appears to slide in and push the select */
    .collapsed-control {
        width: 0 !important;
        min-width: 0 !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
        margin-right: 0 !important;
    }

    /* inner sliding content so buttons appear to slide in from the left
        while their width expands and pushes the select element. No fade. */
    .control-inner {
        display: inline-block;
        transform: translateX(-100%);
        transition: transform 260ms cubic-bezier(.2,.9,.2,1);
        width: 100%;
        box-sizing: border-box;
        will-change: transform;
    }
    .control-inner.in {
        transform: translateX(0);
    }

    /* ensure the select visually adjusts smoothly as buttons expand */
    .custom-select {
        transition: transform 220ms ease, max-width 260ms cubic-bezier(.2,.9,.2,1);
        min-width: 0;
    }

    .slot-btn {
        /* Make the control visually just the SVG (no button chrome) */
        background: transparent;
        border: none;
        /* outline: none; */
    }

    .slot-icon  {
        width: 22px;
        height: 22px;
        display: block;
        fill: #0866e2;
        outline: none
    }

    .slot-number {
        fill: #ffffff;
        font-size: 14px;
        font-weight: 700;
        line-height: 1;
        transform: translate(25%, 80%);
    }

    /* Slot picker floating list styles */
    .slot-picker-list {
        background: #fff;
        border: 1px solid #ddd;
        box-shadow: 0 6px 14px rgba(0,0,0,0.06);
        border-radius: 6px;
        overflow: hidden;
        z-index: 2000;
        /* ensure the floating picker uses the same sans-serif UI font as the table */
        font-family: sans-serif;
    }

    .slot-picker-item {
        padding: 8px 12px;
        cursor: pointer;
        min-height: 40px;
        display: flex;
        align-items: center;
        gap: 8px;
        box-sizing: border-box;
    }

    .slot-picker-item:hover { background: #f5f5f5; }

    .remove-icon-circle {
        fill: #d9534f;
    }

    .remove-icon-line {
        stroke: white;
        stroke-width: 3;
        stroke-linecap: round;
    }

    /* helper styles for animated row removal */
    .row-collapse-inner { display: block; }
    .removing-row td { border: none; padding: 0; }

    /* make inline picker the same height as the action/remove buttons for visual alignment */
    .name-cell select {
        height: 40px;
    }

    #visionCanvas {
      width: 100%;
      max-width: 640px;
      aspect-ratio: 4 / 3;
    }
  </style>
  <link id="favicon" rel="icon" href="favicon.png" type="image/png">
  <script src="ble_sniffer.js" defer></script>
  <script src="dropdown.js" defer></script>
  <script src="project.js" defer></script>
  <script src="visionObject.js" defer></script>
  <script src="vex-ble-device-manager.js" defer></script>
  <script src="indexedDB.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
</head>

<body>

  <h2>VEX IQ BLE Control</h2>
  <div class="controls">
    <div class="row">
      <button id="connectBtn">Connect</button>
      <button id="rename">Rename</button>
    </div>
  </div>
  <table id="pickerTable">
    <thead></thead>
    <tbody></tbody>
  </table>
  <div class="row">
    <canvas id="visionCanvas" width="640" height="480" style="border:1px solid #000; background: #555555"></canvas>
    <div id="structured"></div>
  </div>
  <div class="row">
    <h3>Brain Console</h3>
    <button id="clearBtn">Clear</button>
  </div>
  <div id="stdout"></div>
  <h3>Log</h3>
  <div id="log"></div>

  <!-- modal backdrop goes LAST so it overlays everything -->
  <div id="backdrop" class="modal-backdrop">
    <!-- Modal -->
    <div class="modal">
      <div id="modal-header" class="modal-header">
        Radio Connection Code
      </div>

      <div class="modal-body">
        <span id="modal-text">
          Enter the 4-digit Radio Connection Code displayed on the IQ Brain
        </span>
        <br>
        <input id="modalInput" maxlength="4" />
      </div>

      <div class="modal-footer">
        <button id="modalCancelBtn" class="btn btn-cancel">Cancel</button>
        <button id="modalSubmitBtn" class="btn btn-submit" disabled>Submit</button>
      </div>
    </div>
  </div>

  <div class="ble-progress-wrapper">
    <div class="ble-progress">
      <div class="ble-progress-header">
        <span class="ble-status">Downloading to device…</span>
        <span class="ble-percent" id="blePercent">0%</span>
      </div>

      <div class="ble-progress-track">
        <div class="ble-progress-fill" id="bleProgress"></div>
      </div>
    </div>
  </div>

  <button id="snapshot">Snapshot</button>
  <button id="canvasButton">Show Chart</button>

  <div id="overlay"></div>
  <div id="chartContainer">
    <canvas id="myChart"></canvas>
  </div>

  <script type="module">
    // await SimulateControllerThroughCDC({'leftAxisX': 0.5, 'leftAxisY': 0.5, 'rightAxisX': 0.5, 'rightAxisY': 0.5, 'SEL':0, 'R3':1, 'L3':1, 'RU':1, 'RD':1, 'LU':1, 'LD':1, 'EU':1, 'FU':1, 'ED':1, 'FD':1});

    // =======================================================
    // DOM Elements
    // =======================================================
    const statusEl = document.getElementById("status");
    const connectBtn = document.getElementById("connectBtn");
    const renameBtn = document.getElementById("rename");
    const slotPicker = document.getElementById("slotPicker");
    const clearBtn = document.getElementById('clearBtn')
    const stdout = document.getElementById('stdout');
    const logEl = document.getElementById('log');
    const dataEl = document.getElementById('structured');
    const overlay = document.getElementById('overlay');
    const container = document.getElementById('chartContainer');
    const canvasEl = document.getElementById('myChart');
    const snapBtn = document.getElementById('snapshot');
    const canvasButton = document.getElementById('canvasButton');

    // =======================================================
    // Global variables
    // =======================================================
    /**
    * projects
    * @global
    * @type {Person[]}
    */
    let projects = [];

    let directoryHandles = [];
    let attrs = {};

    /*=============================================================================
    * Table with program pickers and action buttons
    *============================================================================*/
    const tbody = document.querySelector("#pickerTable tbody");

    function getSelectedProjects() {
      const selectedProjects = Array.from(tbody.querySelectorAll('.custom-select'))
        .map(c => c._dropdown && c._dropdown.selectedValue)
        .filter(v => v);

      putData('selectedProjects', selectedProjects);
      return selectedProjects;
    }

    async function pickerDataForProject(project) {
      return {
        text: await project.name(),
        path: project.path,
        value: project,
      };
    }

    // Build dropdown options for a row, keeping currentSelected available
    async function getDropdownOptions(currentProject) {
      const selected = getSelectedProjects();
      // Map project info into the shape Dropdown expects
      return (await Promise.all(
        projects.map(async p => {
          const keep = (await p.equals(currentProject)) || !(await asyncFind(selected, async (x) => p.equals(x)));
          if (!keep) return null;
          return await pickerDataForProject(p);
        })
      )).filter(Boolean);
    }

    async function refreshPickers() {
      Array.from(tbody.querySelectorAll('.custom-select')).forEach(async div => {
        const dropdown = div._dropdown;
        if (!dropdown) return;
        const current = dropdown.selectedValue;
        const opts = await getDropdownOptions(current);
        dropdown.update_options(opts);
        if (current) dropdown.setValue(await pickerDataForProject(current));
      });
      // wait for trailing-row logic to finish so callers see a stable table
      await ensureTrailingEmptyRow();
    }

    async function getAvailableOptions() {
      const selected = getSelectedProjects();
      return await asyncFilter(projects, async p => !(await asyncSome(selected, (x) => p.equals(x))));
    }

    async function ensureTrailingEmptyRow() {
      const available = await getAvailableOptions();
      // Find rows that are "empty" (no selected value)
      const emptyRows = Array.from(tbody.querySelectorAll('tr')).filter(row => {
        const div = row.querySelector('.custom-select');
        return !div || !div._dropdown || !div._dropdown.selectedValue;
      });

      if (available.length > 0) {
        // If there are available options, ensure there is at least one empty picker
        if (emptyRows.length === 0) {
          tbody.appendChild(await createRow(true));
        }
      } else {
        // No available projects: ensure EXACTLY one empty picker remains so the user
        // always has a visible dropdown to click (to trigger empty callback/import)
        if (emptyRows.length === 0) {
          // No empties at all: add one
          tbody.appendChild(await createRow(true));
        } else if (emptyRows.length > 1) {
          // Remove all but the last empty row (leave one available)
          // Prefer keeping the last one so it stays at the bottom
          const rowsToRemove = emptyRows.slice(0, emptyRows.length - 1);
          rowsToRemove.forEach(row => animateRemoveRow(row, () => { /* no-op */ }));
        }
      }
    }

    // Animate a table row collapsing away so the lines above/below come together.
    // This implementation replaces the row with a single-cell wrapper and
    // animates an inner div's height and opacity for smoother behavior.
    // Calls `onComplete` after the row is removed from DOM.
    function animateRemoveRow(row, onComplete) {
      if (!row || row._isRemoving) return;
      row._isRemoving = true;
      const parent = row.parentNode;
      if (!parent) return;

      const rect = row.getBoundingClientRect();
      const initialHeight = rect.height;
      const colCount = row.children.length || 1;

      // Create wrapper row with a single td spanning all columns
      const wrapper = document.createElement('tr');
      wrapper.className = 'removing-row';
      const td = document.createElement('td');
      td.colSpan = colCount;
      td.style.padding = '0';

      const inner = document.createElement('div');
      inner.className = 'row-collapse-inner';
      // preserve the row's inner HTML inside the collapsible div
      inner.innerHTML = row.innerHTML;
      // set styles to make the collapse smooth
      inner.style.overflow = 'hidden';
      inner.style.boxSizing = 'border-box';
      inner.style.height = initialHeight + 'px';
      inner.style.transition = 'height 260ms cubic-bezier(.2,.9,.2,1), opacity 200ms ease';
      inner.style.opacity = '1';

      td.appendChild(inner);
      wrapper.appendChild(td);

      // remember where focus was and a sensible fallback target
      const focusedWasInside = row.contains(document.activeElement);
      let fallbackTarget = null;
      const nextRow = row.nextElementSibling;
      const prevRow = row.previousElementSibling;
      const findFocusable = (r) => r && r.querySelector && r.querySelector('button:not(.hidden), [tabindex], a, input, select, .select-selected');
      if (nextRow) fallbackTarget = findFocusable(nextRow);
      if (!fallbackTarget && prevRow) fallbackTarget = findFocusable(prevRow);

      // replace the original row with wrapper in place
      parent.replaceChild(wrapper, row);

      // force reflow
      inner.getBoundingClientRect();

      // start collapse on next frame
      requestAnimationFrame(() => {
        inner.style.height = '0px';
        inner.style.opacity = '0';
        // also remove any internal td paddings to make lines meet perfectly
        Array.from(inner.querySelectorAll('td')).forEach(it => {
          it.style.transition = 'padding 240ms ease';
          it.style.paddingTop = '0';
          it.style.paddingBottom = '0';
        });
      });

      let cleaned = false;
      const finish = () => {
        if (cleaned) return; cleaned = true;
        if (wrapper.parentNode) wrapper.remove();
        if (typeof onComplete === 'function') onComplete();
        // restore sensible focus if the removed row previously had focus
        if (focusedWasInside) {
          try {
            if (fallbackTarget) fallbackTarget.focus();
            else document.body.focus();
          } catch (e) { /* ignore focus errors */ }
        }
      };

      const onEnd = (ev) => {
        if (ev.target !== inner) return;
        inner.removeEventListener('transitionend', onEnd);
        finish();
      };
      inner.addEventListener('transitionend', onEnd);

      // fallback
      setTimeout(finish, 500);
    }

    async function createRow(isLast = false, initialSelectedProject = null) {
      const tr = document.createElement("tr");

      // create dropdown container and instance
      const ddContainer = document.createElement('div');
      ddContainer.classList.add('custom-select');
      // Await the options so we pass an actual array to Dropdown (not a Promise)
      const initialOpts = await getDropdownOptions(initialSelectedProject);
      const dropdown = new Dropdown(initialOpts, ddContainer, {emptyDisplayText: 'Please select a folder ➡️'});
      // keep reference for refresh logic
      ddContainer._dropdown = dropdown;

      const slotBtn = document.createElement("button");
      slotBtn.className = "slot-btn";
      slotBtn.setAttribute('aria-label', 'Slot');
      // wrap slot icon in control-inner so it can slide in visually
      slotBtn.innerHTML = `<span class="control-inner in"></span>`;
      slotBtn.querySelector('.control-inner').appendChild(makeSlotIcon('1'));
      // clicking the slot button should open a small slot-picker dropdown
      slotBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        // if the slot button is hidden (empty row), do nothing
        if (slotBtn.classList.contains('hidden')) return;
        showSlotPicker(slotBtn, async (num) => {
          slotBtn.querySelector('.slot-number').textContent = num;
          slotBtn.classList.remove('empty');
          const project = ddContainer._dropdown.selectedValue;
          if (project) {
            await project.setSlot(num);
          }
        });
      });

      const playBtn = document.createElement("button");
      playBtn.className = "action-btn run";
      playBtn.setAttribute('aria-label', 'Run');
      playBtn.innerHTML = `<span class="control-inner in">
            <svg viewBox="0 0 16 19" xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true" focusable="false">
              <path d="M277.71,30.091a.8.8,0,0,1,0,1.433l-7.206,4.5-6.674,4.17c-.675.422-1.679.048-1.679-.626V22.3c0-.779,1.16-1.211,1.941-.723l6.411,4.006Z" transform="translate(-262.152 -21.375)" fill="currentColor"/>
            </svg>
            <span class='btn-label'>RUN</span>
          </span>`;
      playBtn.disabled = !bleConnected();

      const stopBtn = document.createElement("button");
      stopBtn.className = "action-btn stop";
      stopBtn.setAttribute('aria-label', 'Stop');
      stopBtn.innerHTML = `<span class="control-inner in">
            <svg viewBox="0 0 19 19" xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true" focusable="false">
              <rect width="19" height="19" rx="2" fill="currentColor"/>
            </svg>
            <span class='btn-label'>STOP</span>
          </span>`;
      stopBtn.disabled = !bleConnected();

      const downloadBtn = document.createElement("button");
      downloadBtn.className = "action-btn download";
      downloadBtn.setAttribute('aria-label', 'Download');
      downloadBtn.innerHTML = `
          <span class="control-inner in">
            <svg viewBox="0 0 24 20" xmlns="http://www.w3.org/2000/svg"
              aria-hidden="true" focusable="false">
              <path d="M-1793,3924a2,2,0,0,1-2-2v-5a2,2,0,0,1,2-2h3.482l5.235,6.406.206.2a1.652,1.652,0,0,0,1.066.39,1.667,1.667,0,0,0,1.278-.6l5.231-6.4h3.5a2,2,0,0,1,2,2v5a2,2,0,0,1-2,2Zm16-3h3v-3h-3Zm-15,0h3v-3h-3Zm8.494-1.235-6.358-7.783a.606.606,0,0,1,.505-.982H-1787v-5a2,2,0,0,1,2-2h4a2,2,0,0,1,2,2v5h2.359a.606.606,0,0,1,.5.981l-6.361,7.784a.652.652,0,0,1-.505.235A.649.649,0,0,1-1783.506,3919.765Z" transform="translate(1795 -3904)" fill="currentColor"/>
            </svg>
            <span class='btn-label'>LOAD</span>
          </span>
      `;
      downloadBtn.disabled = true;
      downloadBtn.classList.add("hidden");

      const removeBtn = document.createElement("button");
      removeBtn.className = "remove-btn";
      removeBtn.setAttribute('aria-label', 'Remove');
      // inline SVG provided by user, scaled down to fit the control
      removeBtn.innerHTML = `<span class="control-inner">
            <svg xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24" width="20" height="20"
              aria-hidden="true" focusable="false">
              <circle class="remove-icon-circle" cx="12" cy="12" r="12"/>
              <line class="remove-icon-line" x1="7" y1="7" x2="17" y2="17"/>
              <line class="remove-icon-line" x1="17" y1="7" x2="7" y2="17"/>
            </svg>
          </span>`;
      // hide remove button for empty rows initially
      removeBtn.classList.add("no_display");

      const openFolderBtn = document.createElement("button");
      openFolderBtn.className = "openFolder-btn";
      openFolderBtn.setAttribute('aria-label', 'Open Folder');
      openFolderBtn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg"
              viewBox = "0 0 80 80"
              fill="none"
              stroke="currentColor"
              stroke-width="6"
              width="32"
              height="32">
              <rect class="hidden" width="100%" height="100%" stroke="none" fill="#FFFFFF" />
              <path d="
                M10,30 v20 q0,10 10,10 h40 q10,0 10,-10 v-20 q0,-10 -10,-10 h-20 q0,-10 -10,-10 h-10 q-10,0 -10,10z"/>
              <g class="plus">
                <circle cx="57.5" cy="52.5" r="20" fill="#2ecc71" stroke="none"/>
                <rect x="47.5" y="49.5" width="20" height="6" rx="3.0" fill="#fff" stroke="none"/>
                <rect x="54.5" y="42.5" width="6" height="20" rx="3.0" fill="#fff" stroke="none"/>
              </g>
              <g class="minus">
                <circle cx="57.5" cy="52.5" r="20" fill="#e74c3c" stroke="none"/>
                <rect x="47.5" y="49.5" width="20" height="6" rx="3.0" fill="#fff" stroke="none"/>
              </g>
            </svg >`;
      openFolderBtn.classList.add("no_display");
      openFolderBtn.addEventListener("click", async () => {
        if (openFolderBtn.querySelector('.plus').classList.contains('hidden')) {
          const result = await deleteAllFolders();
          if (!result) {
            openFolderBtn.classList.remove('shake');
            void openFolderBtn.offsetWidth; // force a repaint
            openFolderBtn.classList.add('shake');
            setTimeout(() => {
              openFolderBtn.classList.remove('shake');
            }, 400);

          }
        } else {
          openFolder();
        }
      });
      openFolderBtn.querySelector('.minus').classList.add('hidden');
      tr.mouseOverBtn = false;
      window.shiftKeyDown = false;
      openFolderBtn.addEventListener('mouseenter', (e) => {
        tr.mouseOverBtn = true;
        if (window.shiftKeyDown) {
          openFolderBtn.querySelector('.plus').classList.add('hidden');
          openFolderBtn.querySelector('.minus').classList.remove('hidden');
        }
      });
      openFolderBtn.addEventListener('mouseleave', (e) => {
        tr.mouseOverBtn = false;
        openFolderBtn.querySelector('.plus').classList.remove('hidden');
        openFolderBtn.querySelector('.minus').classList.add('hidden');

      });
      window.addEventListener('keydown', (e) => {
        if (e.key === 'Shift') {
          window.shiftKeyDown = true;
          if (tr.mouseOverBtn) {
            openFolderBtn.querySelector('.plus').classList.add('hidden');
            openFolderBtn.querySelector('.minus').classList.remove('hidden');
          }
        }
      });
      window.addEventListener('keyup', (e) => {
        if (e.key === 'Shift') {
          window.shiftKeyDown = false;
          if (tr.mouseOverBtn) {
            openFolderBtn.querySelector('.plus').classList.remove('hidden');
            openFolderBtn.querySelector('.minus').classList.add('hidden');
          }
        }
      });

      ddContainer._dropdown.setHoverCallback(() => {
        if (ddContainer._dropdown.getEmpty()) {
          openFolderBtn.classList.add('bounce');
        }
      });

      ddContainer._dropdown.setUnhoverCallback(() => {
        openFolderBtn.classList.remove('bounce');
      });


      const rowTd = document.createElement("td");
      rowTd.classList.add("name-cell");
      rowTd.append(slotBtn, playBtn, stopBtn, downloadBtn, ddContainer, removeBtn, openFolderBtn);
      tr.append(rowTd);

      // Make bouncy connect button effect on play/stop/download disabled button hover
      [playBtn, stopBtn, downloadBtn].forEach(btnToBounce => {
        btnToBounce.addEventListener('mouseenter', () => {
          if (btnToBounce.disabled && (!bleConnected())) {
            connectBtn.classList.add('bounce');
          }
        });
        btnToBounce.addEventListener('mouseleave', () => {
          connectBtn.classList.remove('bounce');
          ddContainer.classList.remove('bounce');
        });
      });
      downloadBtn.addEventListener('mouseenter', () => {
        if (downloadBtn.disabled && bleConnected()) {
          ddContainer.classList.add('bounce');
        }
      });

      // If an initial selection is provided, set the row state accordingly (no change event)
      if (initialSelectedProject) {
          dropdown.setValue(await pickerDataForProject(initialSelectedProject));
          if (bleConnected()) {
            downloadBtn.disabled = false;
            downloadBtn.classList.remove("hidden");
          }
          // set slot button number and mark as filled
          slotBtn.querySelector('.slot-number').textContent = await initialSelectedProject.slot();
          slotBtn.classList.remove("empty");
          // animate controls in if they're hidden
          if (removeBtn.classList.contains('no_display')) revealControls();
      } else {
        openFolderBtn.classList.remove("no_display");
      }

      // Listen for selection events from the Dropdown instance
      ddContainer.addEventListener('dropdown-select', async (e) => {
        const project = e.detail.value;
        if (!project) return;
        // update the slot button display and show it
        slotBtn.querySelector('.slot-number').textContent = await project.slot();
        slotBtn.classList.remove('empty');
        // enable the download button (if connected)
        if (bleConnected()) {
          downloadBtn.disabled = false;
          downloadBtn.classList.remove("hidden");
        }
        // animate controls in (only if not already visible)
        if (removeBtn.classList.contains('no_display')) revealControls();
        // If this is the last row and there are still available options, add a new empty row
        if (tr === tbody.lastElementChild) {
          const available = await getAvailableOptions();
          if (available.length > 0) tbody.appendChild(await createRow(true));
        }
        await refreshPickers();
      });

      function revealControls() {
        const controls = [slotBtn, removeBtn, downloadBtn, stopBtn, playBtn];
        controls.forEach((btn, idx) => {
          btn.classList.remove('hidden');
          btn.classList.remove('no_display');
          const inner = btn.querySelector('.control-inner');
          if (inner) inner.classList.add('in');
        });
        openFolderBtn.classList.add("no_display");
      }

      // Animate the control buttons into view so they slide in and push the select
      function animateControlsIn() {
        // Animate controls starting from the ones adjacent to the select so the
        // select appears pushed as they expand. Slide the inner content from
        // the left while the button width expands so it looks like the buttons
        // were off-screen to the left and are now pushing into place.
        const controls = [slotBtn, removeBtn, downloadBtn, stopBtn, playBtn];
        controls.forEach((btn, idx) => {
          // reveal element (remove display:none)
          btn.classList.remove('hidden');
          // prepare inner sliding state
          const inner = btn.querySelector('.control-inner');
          if (inner) inner.classList.remove('in');
          // start collapsed so it has zero width (push effect)
          btn.classList.add('collapsed-control');
          // force layout then expand width; inner will slide in shortly after
          btn.getBoundingClientRect();
          setTimeout(() => {
            btn.classList.remove('collapsed-control');
            // slight delay so width expansion begins, then slide inner content
            setTimeout(() => { if (inner) inner.classList.add('in'); }, 30);
          }, idx * 50);
        });
      }

      playBtn.addEventListener("click", async () => {
        const project = ddContainer._dropdown.selectedValue;
        let slotIndex;
        if (project) {
          slotIndex = await project.slotIndex();
        } else {
          slotIndex = parseInt(slotBtn.querySelector('.slot-number').textContent) - 1;
        }
        await Play(slotIndex);
      });

      stopBtn.addEventListener("click", Stop);
      downloadBtn.addEventListener("click", async () => {
        const project = ddContainer._dropdown.selectedValue;
        await downloadProject(project);
      });

      removeBtn.addEventListener("click", async () => {
        animateRemoveRow(tr, async () => {
          await refreshPickers();
        });
      });

      return tr;
    }

    async function initSelectAll() {
      tbody.innerHTML = "";
      projects.forEach(async d => {
        tbody.appendChild(await createRow(false, d));
      });
      // ensure pickers are consistent and no trailing empty row is left
      await refreshPickers();
    }

    function makeSlotIcon(n) {
      let icon = document.createElement('div');
      icon.className = 'slot-wrapper';
      icon.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 22 22" aria-hidden="true" focusable="false">
              <path class="slot-icon" d="M429.673,19.5v4.255h-4.007V41.5h18.053V37.331h3.947V19.5Zm16.494,15.672h-2.448V23.752H431.173V21.118h14.994Z" transform="translate(-425.666 -19.497)"/>
              <text class="slot-number" x="0" y="0">${n}</text>
          </svg>
      `;
      return icon;
    }

    // --- Slot picker implementation ---
    // Simple floating picker positioned below the slot button. Calls `onPick(num)`
    // when a number is chosen.
    let _activeSlotPicker = null;
    function showSlotPicker(anchorBtn, onPick) {
      // close existing
      if (_activeSlotPicker) _activeSlotPicker.remove();
      const list = document.createElement('div');
      list.className = 'slot-picker-list';
      [1, 2, 3, 4, 5, 6, 7, 8].forEach(n => {
        const it = document.createElement('div');
        it.className = 'slot-picker-item';
        it.appendChild(makeSlotIcon(n));
        it.addEventListener('click', () => {
          onPick(n);
          list.remove();
          _activeSlotPicker = null;
        });
        list.appendChild(it);
      });
      document.body.appendChild(list);
      _activeSlotPicker = list;
      // position
      const rect = anchorBtn.getBoundingClientRect();
      list.style.position = 'absolute';
      list.style.minWidth = '50px';
      list.style.left = (rect.left + window.scrollX) + 'px';
      list.style.top = (rect.bottom + window.scrollY) + 'px';
      // close on outside click
      const onDocClick = (e) => {
        if (!list.contains(e.target) && e.target !== anchorBtn) {
          list.remove();
          _activeSlotPicker = null;
          document.removeEventListener('click', onDocClick);
        }
      };
      document.addEventListener('click', onDocClick);
      // make sure picking an item removes the outside-click listener as well
      Array.from(list.children).forEach(child => {
        child.addEventListener('click', () => { document.removeEventListener('click', onDocClick); });
      });
    }

    /*=============================================================================
    * BLE Progress UI Controller
    *============================================================================*/
    function setBleProgress(percent, status) {
      const bar = document.getElementById("bleProgress");
      const label = document.getElementById("blePercent");
      const statusEl = document.querySelector(".ble-status");

      bar.style.width = percent + "%";
      label.textContent = percent + "%";

      if (status) {
        statusEl.textContent = status;
      }
    }

    const BleProgressUI = (() => {
      let lastPercent = 0;
      let visible = false;

      function container() {
        return document.querySelector(".ble-progress");
      }

      function setPercent(percent, statusText) {
        const el = container();
        if (!el) return;

        lastPercent = Math.max(0, Math.min(100, percent));

        el.classList.remove("error", "complete");
        el.classList.add("active");

        setBleProgress(lastPercent, statusText);
      }

      function setInProgress(statusText = "Downloading…") {
        const el = container();
        if (!el) return;

        el.classList.remove("frozen", "error", "complete");
        el.classList.add("active");

        setBleProgress(lastPercent, statusText);
      }

      function setSuccess(statusText = "Complete") {
        const el = container();
        if (!el) return;

        lastPercent = 100;

        el.classList.remove("active", "error");
        el.classList.add("complete");

        setBleProgress(100, statusText);
      }

      function setFailure(statusText = "Transfer failed") {
        const el = container();
        const wrapper = document.querySelector(".ble-progress-wrapper");
        if (!el || !wrapper) return;

        // Stop progress animation immediately
        el.classList.add("frozen");

        el.classList.remove("active", "complete");
        el.classList.add("error");

        // Wait one frame so width transition is fully cancelled
        requestAnimationFrame(() => {
          // Full-screen flash
          wrapper.classList.remove("flash-error");
          wrapper.offsetHeight; // force reflow
          wrapper.classList.add("flash-error");
        });

        setBleProgress(lastPercent, `Error: ${statusText}`);
      }

      function show() {
        const el = container();
        const wrapper = document.querySelector(".ble-progress-wrapper");
        visible = true;
        wrapper.classList.remove("hidden");
        el.classList.remove("hidden")
      }

      function hide() {
        const el = container();
        const wrapper = document.querySelector(".ble-progress-wrapper");
        visible = false;
        wrapper.classList.add("hidden");
        el.classList.add("hidden")
      }

      function getLastPercent() {
        return lastPercent;
      }

      function isVisible() {
        return visible;
      }

      hide();

      return {
        setPercent,
        setInProgress,
        setSuccess,
        setFailure,
        show,
        hide,
        getLastPercent,
        isVisible
      };
    })();

    BleProgressUI.hide();

    let progress;

    function downloadCallback(prog_dict) {
      const current_time = Date.now();
      const current_progress = prog_dict.progress * 100;
      console.log(`Downloading:`, prog_dict);
      BleProgressUI.show();
      BleProgressUI.setInProgress("Downloading" + " .".repeat(Math.floor((current_time % 2000) * 4 / 2000)));
      BleProgressUI.setPercent(Math.floor(current_progress));
      if (prog_dict.progress == 1) {
        BleProgressUI.setSuccess("Download Complete!");
      }
      progress = current_progress;
    }

    async function asyncFilter(arr, asyncCallbackFn) {
      const results = await Promise.all(arr.map(asyncCallbackFn));
      return arr.filter((_element, index) => results[index]);
    };

    async function asyncFindIndex(arr, asyncCallbackFn) {
      const results = await Promise.all(arr.map(asyncCallbackFn));
      return results.findIndex(result => result);
    }

    async function asyncFind(arr, asyncCallbackFn) {
      const index = await asyncFindIndex(arr, asyncCallbackFn);
      return arr[index];
    }

    async function asyncSome(arr, asyncCallbackFn) {
      for await (const result of arr.map(asyncCallbackFn))
      {
        if (result) return true;
      }
      return false;
    }

    async function filterEqualProjects(arr) {
      const result = [];
      for (const project of arr) {
          const index = await asyncFindIndex(result, existing => existing.equals(project));
          if (index === -1) {
              // No equivalent object yet, add it
              result.push(project);
          }
      }
      return result;

      // return asyncFilter(arr, async (element, index, array) => {
      //   return index === await asyncFindIndex(array, e => e.equals(element));
      // });
    }

    async function findAllProjectsInDirectories(dir_handles) {
      let newProjects = [];
      for (const handle of dir_handles) {
        newProjects.push(...await findAllProjects([handle], null));
      }
      return await filterEqualProjects(newProjects);
    }

    async function findAllProjects(dir_handles, path = null, project_arr = []) {
      if (!dir_handles) {
        return project_arr;
      }
      const final_dir = dir_handles.at(-1);
      for await (const entry of final_dir.values()) {
        const fullPath = `${path ?? final_dir.name}/${entry.name}`;
        if (entry.kind === 'file') {
          if (entry.name == 'vex_project_settings.json') {
            // MyProject          / .vscode            / vex_project_settings.json
            // ^                    ^                    ^
            // |                    |                    |
            // dir_handles.at(-2)   dir_handles.at(-1)   entry
            // project_dir
            const project_path = fullPath.split('/').slice(0, -2).join('/');
            const project_dir = dir_handles.at(-2);
            const jsonFile = await entry.getFile();
            const jsonText = await jsonFile.text();
            const settings = JSON.parse(jsonText);
            if (settings.project.language === "python") {
              project_arr.push(new Project(project_path, project_dir));
            }
          }
          else if (entry.name.endsWith('.iqpython')) {
            project_arr.push(new Project(fullPath, entry));
          }
        } else if (entry.kind === 'directory') {
          const new_handles = dir_handles.slice();
          new_handles.push(entry);
          // Recursively call for subdirectories
          await findAllProjects(new_handles, fullPath, project_arr);
        }
      }
      return project_arr;
    }

    async function dedupeDirectoryHandles() {
      for (let i = 0; i < directoryHandles.length; i++) {
        for (let j = i + 1; j < directoryHandles.length; j++) {
          if (await directoryHandles[i].isSameEntry(directoryHandles[j])) {
              directoryHandles.splice(j, 1);
              j--; // adjust index after removal
          }
        }
      }
      putData('directoryHandles', directoryHandles);
    }

    async function getPermission(handle) {
      if (!handle) return null;
      const opts = { mode: 'readwrite' };
      let permissionGranted = (await handle.queryPermission(opts) === 'granted');
      if (!permissionGranted) {
        permissionGranted = ((await handle.requestPermission(opts)) === 'granted');
      }
      return permissionGranted ? handle : null;
    }

    async function loadDirectories() {
      const handlesFromDb = (await getData('directoryHandles') ?? []);
      const newHandles = (await Promise.all(
        handlesFromDb.map(getPermission)
      )).filter(Boolean);
      directoryHandles.push(...newHandles);
      await dedupeDirectoryHandles();
      const loadedProjects = await findAllProjectsInDirectories(directoryHandles);
      projects = await filterEqualProjects(projects.concat(loadedProjects));
      putData('projects', projects);
      await refreshPickers();
    }

    async function openFolder() {
      let newHandle = await window.showDirectoryPicker({
        id: 'handle-picker',
        mode: 'readwrite',
      });
      directoryHandles.push(newHandle);
      await dedupeDirectoryHandles();
      const loadedProjects = await findAllProjectsInDirectories(directoryHandles);
      projects = await filterEqualProjects(projects.concat(loadedProjects));
      putData('projects', projects);
      await refreshPickers();
    }

    async function deleteAllFolders() {
      if (!directoryHandles || directoryHandles.length == 0) {
        return false;
      }
      if (!(await promptForClearFoldersModal())) {
        return true;
      }
      try {
        await delData('directoryHandles');
        await delData('projects');
        await delData('selectedProjects');
      } catch (e) {
        console.warn("Error deleting data:", e);
        console.warn("Hopefully, it worked.");
      }
      directoryHandles = [];
      projects = [];
      tbody.innerHTML = "";
      await refreshPickers();
      return true;
    }

    async function loadProjects() {
      let storedProjects = await getData('projects');
      storedProjects = (storedProjects ?? []).filter(Boolean).map(p => Project.fromStored(p));
      projects = await filterEqualProjects(projects.concat(storedProjects));
      putData('projects', projects);

      let selectedProjects = await getData('selectedProjects');
      selectedProjects = (selectedProjects ?? []).map(p => Project.fromStored(p)).filter(Boolean);
      for (const p of selectedProjects) {
        tbody.appendChild(await createRow(false, p));
      }
      await refreshPickers();
    }

    /**
     * Rejects if `getValue()` does not change for `ms` milliseconds
     * @param {Function} getValue - Function that returns the current value to watch
     * @param {Promise} promise - The promise to wrap
     * @param {number} ms - Maximum idle time before rejecting
     */
    function withIdleTimeout(getValue, promise, ms) {
      return new Promise((resolve, reject) => {
        let lastValue = getValue();
        let timer = setTimeout(() => {
          reject(new Error(`Operation stalled: value did not change for ${ms} ms`));
        }, ms);

        // Periodically check for change
        const interval = setInterval(() => {
          const current = getValue();
          if (current !== lastValue) {
            lastValue = current;
            clearTimeout(timer);
            timer = setTimeout(() => {
              reject(new Error(`Operation stalled: value did not change for ${ms} ms`));
            }, ms);
          }
        }, 100); // check every 100 ms

        promise
          .then((res) => {
            clearTimeout(timer);
            clearInterval(interval);
            resolve(res);
          })
          .catch((err) => {
            clearTimeout(timer);
            clearInterval(interval);
            reject(err);
          });
      });
    }

    /*
    * @param {Project} project
    */
    async function downloadProject(project) {
      if (project) {
        BleProgressUI.show();
        BleProgressUI.setInProgress("Preparing download...");
        BleProgressUI.setPercent(0);
        const programText = await project.programText();
        console.log("Text:", programText);
        let encoder = new TextEncoder();
        let programData = encoder.encode(programText);
        const slotNum = await project.slot();
        const slotIndex = await project.slotIndex();
        const projectName = await project.name();
        const displayName = `${slotNum}:${projectName}`;
        console.log(await project.name());
        let downloadComplete = false;
        let success;
        try {
          success = await withIdleTimeout(() => progress, downloadProgram(slotIndex, displayName, "python", programData, downloadCallback, "Python"), 3000);
        } catch (e) {
          BleProgressUI.setFailure("Download failed");
          setTimeout(BleProgressUI.hide, 2000);
          return;
        }
        if (success) {
          BleProgressUI.setSuccess("Download Complete!");
          setTimeout(BleProgressUI.hide, 750);
        } else {
          BleProgressUI.setFailure("Brain disconnected");
          setTimeout(BleProgressUI.hide, 2000);
        }
      } else {
        alert("No program selected. Please select a file first.");
        return;
      }
    }

    function enable_buttons() {
      document.querySelectorAll('.name-cell').forEach(nameCell => {
        nameCell.querySelector('.action-btn.run').disabled = false;
        nameCell.querySelector('.action-btn.stop').disabled = false;
        const project = nameCell.querySelector('.custom-select')._dropdown.selectedValue;
        if (project) {
          const downloadBtn = nameCell.querySelector('.action-btn.download');
          downloadBtn.disabled = false;
          downloadBtn.classList.remove("hidden");
        }
      });
      renameBtn.disabled = false;
    }

    function disable_buttons() {
      document.querySelectorAll('.name-cell').forEach(nameCell => {
        nameCell.querySelector('.action-btn.run').disabled = true;
        nameCell.querySelector('.action-btn.stop').disabled = true;
        nameCell.querySelector('.action-btn.download').disabled = true;
        nameCell.querySelector('.action-btn.download').classList.add("hidden");
      });
      renameBtn.disabled = true;
    }

    function log(msg) {
      const line = document.createElement('div');
      line.textContent = msg;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog() {
      logEl.innerHTML = '';
      logEl.scrollTop = 0;
    }

    function clearStdout() {
      stdout.innerHTML = '';
      stdout.scrollTop = 0;
    }

    function clearBoth() {
      clearLog();
      clearStdout();
    }

    // =======================================================
    // Modal Dialog for Bluetooth pairing code entry
    // =======================================================
    const backdrop = document.getElementById("backdrop");
    const modalText = document.getElementById("modal-text");
    const modalInput = document.getElementById("modalInput");
    const modalSubmitBtn = document.getElementById("modalSubmitBtn");
    const modalCancelBtn = document.getElementById("modalCancelBtn");
    const modalHeader = document.getElementById("modal-header");

    function modalPrompt(prompt, regex, header, input_max_len = 0, default_input = "") {
      return new Promise((resolve, reject) => {
        modalText.textContent = prompt;
        backdrop.style.display = "flex";
        document.body.style.overflow = "hidden";
        modalInput.value = default_input;
        modalHeader.textContent = header;
        if (input_max_len === null) {
          modalInput.disabled = true;
          modalInput.style.display = 'none';
          modalSubmitBtn.classList.add("enabled");
          modalSubmitBtn.disabled = false;
          modalSubmitBtn.textContent = "Yes";
        }
        else {
          modalInput.disabled = false;
          modalInput.style.display = 'block';
          modalSubmitBtn.disabled = true;
          modalSubmitBtn.classList.remove("enabled");
          modalSubmitBtn.textContent = "Submit";
        }
        if (input_max_len <= 0) {
          modalInput.removeAttribute("maxLength");
        }
        else {
          modalInput.maxLength = input_max_len;
        }
        modalInput.classList.remove("invalid");


        requestAnimationFrame(() => modalInput.focus()); // Focus after render

        function cleanup() {
          backdrop.style.display = "none";
          document.body.style.overflow = "";
          modalInput.removeEventListener("input", onInputChange);
          modalInput.removeEventListener("keydown", onInputKeyDown);
          modalSubmitBtn.removeEventListener("click", onSubmit);
          modalCancelBtn.removeEventListener("click", onCancel);
          document.removeEventListener("keydown", onKeyDown);
        }

        function onInputChange() {
          // Enable submit for correct regex
          if (regex.test(modalInput.value)) {
            modalSubmitBtn.disabled = false;
            modalSubmitBtn.classList.add("enabled");
            modalInput.classList.remove("invalid");
          } else {
            modalSubmitBtn.disabled = true;
            modalSubmitBtn.classList.remove("enabled");
            if (modalInput.value.length !== 0) {
              modalInput.classList.add("invalid");
            } else {
              modalInput.classList.remove("invalid");
            }
          }
        }

        function getValidInput() {
          // must be exactly 4 decimal digits
          const v = modalInput.value;
          if (regex.test(v)) {
            return v;
          }
          else {
            console.warn("invalid");
            return "";
          }
        }

        function onSubmit() {
          if (input_max_len !== null) {
            const v = getValidInput();
            if (!v) {
              modalInput.classList.add("invalid");
              return;
            }
          }
          cleanup();
          if (input_max_len !== null) {
            resolve(modalInput.value);
          } else {
            resolve(true);
          }
        }

        function onCancel() {
          cleanup();
          resolve(null);
        }

        function onInputKeyDown(e) {
          if (e.key === "Enter") {
            if (getValidInput()) {
              onSubmit();
            } else {
              // Disable invalid Enter submissions
              e.preventDefault();
            }
          }
        }

        function onKeyDown(e) {
          if (e.key === "Escape") {
            onCancel();
          }
        }

        modalInput.addEventListener("input", onInputChange);
        modalInput.addEventListener("keydown", onInputKeyDown);
        modalSubmitBtn.addEventListener("click", onSubmit);
        modalCancelBtn.addEventListener("click", onCancel);
        document.addEventListener("keydown", onKeyDown);
      });
    }


    async function promptForConnectionCodeModal() {
      return modalPrompt("Enter the 4-digit Radio Connection Code displayed on the IQ Brain", /^\d{4}$/, "Radio Connection Code", 4);
    }

    async function promptForNewNameModal() {
      return modalPrompt("Update Brain Name", /^\S*$/, "Rename", 0, attrs.robotname ?? "");
    }

    async function promptForClearFoldersModal() {
      return modalPrompt("Are you sure you want to remove all previously selected folders?", /\S\s/, "Erase All?", null);
    }

    async function renameBrain() {
      let new_name = await promptForNewNameModal();
      if (new_name === null) {
        return;
      }
      await setRobotName(new_name);
      log(`Brain renamed ${new_name}`);
    }

    // =======================================================
    // Stdout
    // =======================================================
    let byteBuffer = new ArrayBuffer(0);

    function combineArrayBuffers(buffer1, buffer2) {
      const totalLength = buffer1.byteLength + buffer2.byteLength;

      const combinedBuffer = new ArrayBuffer(totalLength);

      const view1 = new Uint8Array(buffer1);
      const view2 = new Uint8Array(buffer2);
      const combinedView = new Uint8Array(combinedBuffer);

      combinedView.set(view1, 0); // Copy buffer1 data starting at index 0
      combinedView.set(view2, buffer1.byteLength); // Copy buffer2 data after buffer1's data

      return combinedBuffer;
    }

    const fmt_for_data = {};
    const code_lens = {
      "b": 1,
      "B": 1,
      "h": 2,
      "H": 2,
      "i": 4,
      "I": 4,
      "l": 4,
      "L": 4,
      "q": 8,
      "Q": 8,
      "e": 2,
      "f": 4,
      "d": 8,
    };

    function get_data(data, index, fmt_code) {
      const fmt_funcs = {
        "b": (data, index) => data.getInt8(index),
        "B": (data, index) => data.getUint8(index),
        "h": (data, index) => data.getInt16(index),
        "H": (data, index) => data.getUint16(index),
        "i": (data, index) => data.getInt32(index),
        "I": (data, index) => data.getUint32(index),
        "l": (data, index) => data.getInt32(index),
        "L": (data, index) => data.getUint32(index),
        "q": (data, index) => data.getInt64(index),
        "Q": (data, index) => data.getUint64(index),
        "e": (data, index) => data.getFloat16(index),
        "f": (data, index) => data.getFloat32(index),
        "d": (data, index) => data.getFloat64(index),
      }
      const func = fmt_funcs[fmt_code];
      if (func === null) {
        console.error(`Unsupported format code: ${fmt_code}`);
      }
      return func(data, index);
    }

    const data_dict = {};

    let graph_data = Array.from({ length: 40 });
    for (let i = 0; i < graph_data.length; i++) {
      graph_data[i] = { ...data_dict };
    }

    function update_graph() {
      graph_data.push(graph_data.shift());
      graph_data[graph_data.length - 1] = { ...data_dict };

    }

    function updateDatasets() {
      if (myChart === null) return;
      const cookie = JSON.parse(localStorage.getItem('GraphShownLines')) ?? {};
      let i = 0;
      for (const name of Object.keys(data_dict)) {
        const dataIndex = myChart.data.datasets.findIndex(dataset => dataset.label === name);
        if (dataIndex === -1) {
          const color = brightColors[i % brightColors.length];
          const dataset = {
            label: name,
            data: new Array(40).fill(0),
            yAxisID: 'y',
            borderColor: color,
            backgroundColor: color.replace('1)', '0.2)'),
            hidden: (cookie[name]) || (name != 'Heading'),
            fill: false,
            tension: 0,
          };
          myChart.data.datasets.push(dataset);
        }
        i++;
      }
    }

    /**
    * @param {DataView} data
    */
    function unpack_vals(data, index, length) {
      // const view = new DataView(data.buffer, data.byteOffset + index, length);

      for (let i = index; i < index + length && i < data.byteLength;) {
        let code;
        [code, i] = getVarInt(data, i);
        const fmt_list = fmt_for_data[code];
        if (fmt_list === undefined) {
          console.warn(`Code ${code} doesn't exist`);
          return;
        }
        const [name, fmt] = fmt_for_data[code];
        const val_len = code_lens[fmt];
        data_dict[name] = get_data(data, i, fmt);
        i += val_len;
      }
      // display data
      let data_str = "";
      for (const [name, val] of Object.entries(data_dict)) {
        data_str += `${name}: ${String(val.toFixed(1)).padStart(10)}\n`;
      }
      dataEl.textContent = data_str;
    }

    /**
    * @param {DataView} msg
    */
    function process_format_msg(msg) {
      for (let i = 0; i < msg.byteLength;) {
        let code;
        [code, i] = getVarInt(msg, i);
        const fmt = msg.getUint8(i);
        i += 1;

        const j = msg.byteOffset + i;
        const nullByteIndex = new Uint8Array(msg.buffer).indexOf(0, j)
        if (nullByteIndex >= 0) {
          const nameLength = nullByteIndex - j;
          const name = (new TextDecoder()).decode(new DataView(msg.buffer, j, nameLength));
          fmt_for_data[code] = [name, String.fromCharCode(fmt)];
          if (data_dict[name] === undefined) {
            data_dict[name] = 0;
          }
          i += (nameLength + 1);
        } else {
          throw Error(`Can't find null byte in msg:`, msg);
        }
      }
      updateDatasets();
    }

    const tagImages = new Map();
    function loadAprilTags() {
      for (let i = 0; i <= 37; i++) {
        const img = new Image();
        const id = i.toString().padStart(5, "0");
        img.src = `assets/AprilTagImgs/tag21_07_${id}.png`;
        tagImages.set(i, img);
      }
    }

    function setAffineFromTriangles(ctx, src, dst) {
      // src, dst: arrays of 3 points: [{x,y}, {x,y}, {x,y}]

      const [s0, s1, s2] = src;
      const [d0, d1, d2] = dst;

      // Solve:  [a c e] [sx] = [dx]
      //         [b d f] [sy]   [dy]
      //         [0 0 1] [1 ]   [1 ]

      const denom =
        s0.x * (s1.y - s2.y) +
        s1.x * (s2.y - s0.y) +
        s2.x * (s0.y - s1.y);

      const a =
        (d0.x * (s1.y - s2.y) +
          d1.x * (s2.y - s0.y) +
          d2.x * (s0.y - s1.y)) / denom;

      const b =
        (d0.y * (s1.y - s2.y) +
          d1.y * (s2.y - s0.y) +
          d2.y * (s0.y - s1.y)) / denom;

      const c =
        (d0.x * (s2.x - s1.x) +
          d1.x * (s0.x - s2.x) +
          d2.x * (s1.x - s0.x)) / denom;

      const d =
        (d0.y * (s2.x - s1.x) +
          d1.y * (s0.x - s2.x) +
          d2.y * (s1.x - s0.x)) / denom;

      const e =
        (d0.x * (s1.x * s2.y - s2.x * s1.y) +
          d1.x * (s2.x * s0.y - s0.x * s2.y) +
          d2.x * (s0.x * s1.y - s1.x * s0.y)) / denom;

      const f =
        (d0.y * (s1.x * s2.y - s2.x * s1.y) +
          d1.y * (s2.x * s0.y - s0.x * s2.y) +
          d2.y * (s0.x * s1.y - s1.x * s0.y)) / denom;

      ctx.setTransform(a, b, c, d, e, f);
    }

    function clipTriangle(ctx, p0, p1, p2) {
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.closePath();
      ctx.clip();
    }

    function drawImageInQuad(ctx, img, quad) {
      const w = img.width;
      const h = img.height;
      const img_points = [{ x: 0, y: 0 }, { x: w, y: 0 }, { x: w, y: h }, { x: 0, y: h }]
      const img_center = { x: w/2, y: h/2 };
      const cx = quad.reduce((s, p) => s + p.x, 0) / 4;
      const cy = quad.reduce((s, p) => s + p.y, 0) / 4;
      const quad_center = { x: cx, y: cy };
      const [p0, p1, p2, p3] = quad;

      for (let i = 0; i < 4; ++i) {
        const j = (i + 1) % 4;
        ctx.save();
        clipTriangle(ctx, quad[i], quad[j], quad_center);
        setAffineFromTriangles(
          ctx,
          [img_points[i], img_points[j], img_center],
          [quad[i], quad[j], quad_center]
        );
        ctx.drawImage(img, 0, 0);
        ctx.restore();
      }
    }

    function drawVisionObjects(objs) {
      const canvas = document.getElementById('visionCanvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.imageSmoothingEnabled = false;

      objs.forEach(obj => {
        const scale = 2;
        const x = obj.originX * scale;
        const y = obj.originY * scale;
        const w = obj.width * scale;
        const h = obj.height * scale;
        // Bounding box
        ctx.lineWidth = 2;
        if (obj.quad && obj.quad9) {
          // ---------- QUAD (tag points) ----------
          const scalePointBy = scale => p => ({x: p.x * scale, y: p.y * scale});
          const scaleFunc = scalePointBy(scale);
          const quad = obj.quad.map(scaleFunc);
          const quad9 = obj.quad9.map(scaleFunc);

          // Draw AprilTag image
          const img = tagImages.get(obj.id);
          if (img && img.complete) {
            drawImageInQuad(ctx, img, quad9);
          }

          // draw quad on top
          ctx.beginPath();
          quad.forEach((p, i) => i ? ctx.lineTo(p.x, p.y) : ctx.moveTo(p.x, p.y));
          ctx.closePath();
          ctx.strokeStyle = "lime";
          ctx.stroke();
        } else {
          // draw boring rectangle
          switch (obj.name) {
            case "Blue Pin":
              ctx.strokeStyle = "darkcyan";
              break;
            case "Red Pin":
              ctx.strokeStyle = "crimson";
              break;
            case "Orange Pin":
              ctx.strokeStyle = "darkorange";
              break;
            default:
              ctx.strokeStyle = "white";
              break;
          }
          ctx.strokeRect(x, y, w, h);
        }

        // Center crosshair
        const cx = obj.centerX * scale;
        const cy = obj.centerY * scale;
        const r = 6; // half-length of crosshair arms
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx - r, cy);
        ctx.lineTo(cx + r, cy);
        ctx.moveTo(cx, cy - r);
        ctx.lineTo(cx, cy + r);
        ctx.stroke();
        // ---------- LABEL ----------
        ctx.font = "14px monospace";
        const pad = 6;
        const lineHeight = 16;
        const labelLines = [
          obj.name,
          ...((obj.type === 3) ? [`A:${obj.angle.toFixed(0)}°`] : []),
          `CX:${obj.centerX} CY:${obj.centerY}`,
          `W:${obj.width} H:${obj.height}`,
          ...((obj.type === 2) ? [`Score:${obj.score}%`] : [])
        ];

        const labelWidth =
          Math.max(...labelLines.map(l => ctx.measureText(l).width)) + pad * 2;
        const labelHeight =
          labelLines.length * lineHeight + pad * 2;

        // Prefer above
        let labelX = x;
        let labelY = y - labelHeight;

        // If above doesn't fit, move below
        if (labelY < 0) {
          labelY = y + h;
        }

        // Clamp horizontally to canvas
        labelX = Math.max(0, Math.min(labelX, canvas.width - labelWidth));

        // Background
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(labelX, labelY, labelWidth, labelHeight);

        // Text
        ctx.fillStyle = "white";
        labelLines.forEach((line, idx) => {
          ctx.fillText(
            line,
            labelX + pad,
            labelY + pad + (idx + 1) * lineHeight - 4
          );
        });
      });
    }

    function process_vision_data(payload) {
      let objects = [];
      const payloadTotalLength = payload.byteOffset + payload.byteLength;
      for (let offset = payload.byteOffset; offset < payloadTotalLength;) {
        const vo_bytes = new DataView(payload.buffer, offset);
        const obj = new VisionObject(vo_bytes);
        objects.push(obj);
        offset += obj.byteLength;
      }
      drawVisionObjects(objects);
    }

    function process_special_message(cmd, payload) {
      if (cmd === 0x44) {
        // data message
        unpack_vals(payload, 0, payload.byteLength);
        update_graph();
      } else if (cmd === 0x46) {
        process_format_msg(payload);
      } else if (cmd === 0x49) {
        process_vision_data(payload);
      } else {
        console.warn(`Unknown special message cmd: ${cmd}`);
      }
    }

    /**
    * @param {DataView} dv
    * @param {Number} offset
    */
    function getVarInt(dv, offset) {
      let result = dv.getUint8(offset);
      if (result & 0x80) {
        // 16 bit value
        result = dv.getUint16(offset) & 0x7FFF;
        return [result, offset+2];
      } else {
        // 8 bit value
        return [result, offset+1];
      }
    }

    function checkForHeader(data, offset, header) {
      let headerIndex = 0;
      for (let i = offset; i < data.byteLength; i++) {
        if (data.getUint8(i) === header[headerIndex]) {
          headerIndex++;
          if (headerIndex >= header.length) {
            return (i - header.length) + 1;
          }
        } else {
          headerIndex = 0;
        }
      }
      if (headerIndex !== null) {
        return data.byteLength - headerIndex;
      }
      return null;
    }

    function appendToStdout(text) {
      // Check if the user is already at or near the bottom (e.g., within 1 pixel inaccuracy)
      const isScrolledToBottom = stdout.scrollHeight - stdout.clientHeight <= stdout.scrollTop + 1;
      // append new text
      stdout.textContent += text;
      // Only scroll to the bottom if they were already there
      if (isScrolledToBottom) {
        stdout.scrollTop = stdout.scrollHeight;
      }
    }

    function stdout_handler(event) {
      const combinedBuffer = combineArrayBuffers(byteBuffer, event.target.value.buffer);
      // clear byteBuffer, if we still need it, we will write into it again
      byteBuffer = new ArrayBuffer(0);
      const dv = new DataView(combinedBuffer);
      for (let i = 0; i < dv.byteLength;) {
        const headerOffset = checkForHeader(dv, i, [0xc0, 0xde]);
        if (headerOffset === null) {
          // no header found
          // print all bytes to console
          const text = new TextDecoder().decode(new DataView(dv.buffer, i))
          appendToStdout(text);
          return;
        } else {
          // print bytes up to headerOffset to console
          const text = new TextDecoder().decode(new DataView(dv.buffer, i, (headerOffset - i)))
          appendToStdout(text);

          i = headerOffset;
          if (   ((i + 3) < dv.byteLength)
              && (   ((dv.getUint8(i + 3) & 0x80) === 0x00) // payload_len is 1 byte
                  || ((i + 4) < dv.byteLength)) // payload_len is 2 bytes, and that byte is available
            ) {
              const cmd = dv.getUint8(i + 2);
              const [payload_len, payload_offset] = getVarInt(dv, i + 3);
              if ((payload_offset + payload_len) <= dv.byteLength) {
                // full payload present
                process_special_message(cmd, new DataView(dv.buffer, payload_offset, payload_len));
                // unpack_vals(dv, i + 3, pack_len - 2);
                i = payload_offset + payload_len;
              } else {
                // incomplete packet
                // store in byteBuffer until next packet
                byteBuffer = dv.buffer.slice(i);
                return;
              }
          } else {
            // incomplete packet
            // store in byteBuffer until next packet
            byteBuffer = dv.buffer.slice(i);
            return;
          }
        }
      }
    }

    // =======================================================
    // BLE connection to Brain
    // =======================================================
    function disconnect_callback() {
      disable_buttons();
      disconnect();
      attrs = {};
      connectBtn.removeEventListener('click', disconnect_callback);
      connectBtn.addEventListener('click', connect);
      connectBtn.textContent = "Connect";
    }

    async function EnterLockCode_callback(webble_gatt_uuid, UniqueDeviceID) {
      let pair_key = `BLE_LOCK_KEY${UniqueDeviceID.toString(10)}`;
      log(`Looking for cookie: ${pair_key}`);
      let pair_code = localStorage.getItem(pair_key);

      do {
        if (pair_code === null) {
          // command the brain to display the "Bluetooth ID" pairing code
          ShowLockCodeOnBrain(true);
          // prompt the user to enter the pair code from the brain
          pair_code = await promptForConnectionCodeModal();
          if (pair_code === null) {
            // canceled; clear the brain display and disconnect
            ShowLockCodeOnBrain(false);
            disconnect_callback();
            return;
          }
        }
        let unlocked = await SendLockCode(Number(pair_code));
        if (!unlocked) {
          log('Pair code failed');
          pair_code = null;
        }
      } while (pair_code === null)

      // pairing successful; store/update the code
      log(`Storing code: ${pair_code} to key: ${pair_key}`);
      localStorage.setItem(pair_key, pair_code);
    }

    async function connect() {
      connectBtn.textContent = "Connecting...";
      connectBtn.disabled = true;
      connectBtn.classList.add('bounce-slow');
      try {
        await scanAndConnect();
      } catch (e) {
        connectBtn.textContent = "Connect";
        connectBtn.disabled = false;
        connectBtn.classList.remove('bounce-slow');
        return;
      }

      enable_buttons()
      connectBtn.textContent = "Disconnect";
      connectBtn.disabled = false;
      connectBtn.removeEventListener('click', connect);
      connectBtn.addEventListener('click', disconnect_callback);
      connectBtn.classList.remove('bounce-slow');
    }

    function bleConnected() {
      return bleDeviceManager && bleDeviceManager.isConnected();
    }

    // =======================================================
    // Chart display
    // =======================================================
    let myChart = null;
    const labels = Array.from({ length: 40 }, (_, i) => i * 50);
    let config = {
        type: 'line',
        data: {
          labels: labels,
          datasets: []
        },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              min: -180,    // force bottom of y-axis
              max: 180,    // force top of y-axis
              position: 'left',
            },
            y2: {
              min: -2,    // force bottom of y-axis
              max: 2,    // force top of y-axis
              position: 'right',
            }
          }
        }
      };


    const brightColors = [
      'rgba(255, 99, 132, 1)',    // red
      'rgba(54, 162, 235, 1)',    // blue
      'rgba(255, 206, 86, 1)',    // yellow
      'rgba(75, 192, 192, 1)',    // teal
      'rgba(153, 102, 255, 1)',   // purple
      'rgba(255, 159, 64, 1)',    // orange
      'rgba(0, 128, 0, 1)',       // green
      'rgba(255, 0, 255, 1)',     // magenta
      'rgba(0, 255, 255, 1)',     // cyan
      'rgba(128, 0, 0, 1)'        // dark red
    ];


    // Show/hide chart + overlay
    function showHideChart() {
      const isHidden = container.style.display === 'none' || container.style.display === '';
      container.style.display = isHidden ? 'block' : 'none';
      overlay.style.display = isHidden ? 'block' : 'none';
      snapBtn.style.display = isHidden ? 'block' : 'none';

      if (isHidden) {
        // Initialize chart after container is visible
        if (!myChart) {
          const ctx = canvasEl.getContext('2d');
          myChart = new Chart(ctx, config);
        } else {
          myChart.resize(); // resize if chart already exists
        }
      }
    }

    // Automatically resize chart when window changes size
    function resizeChart() {
      if (myChart && container.style.display === 'block') {
        myChart.resize();
      }
    }

    let frozen = false;
    function toggleFreezeChart() {
      frozen = !frozen;
    }

    async function chart_loop() {
      if (myChart !== null) {
        update_graph();
        if (!frozen) {
          var cookie_changed = false;
          var cookie = JSON.parse(localStorage.getItem('GraphShownLines'));
          if (cookie === null) {
            console.log("Null cookie")
            cookie = {};
            cookie_changed = true;
          }
          for (var i = 0; i < myChart.data.datasets.length; i++) {
            const data_name = myChart.data.datasets[i].label;
            const meta = myChart.getDatasetMeta(i);
            const hidden = meta.hidden;
            //console.log(data_name, ":", hidden);
            if (hidden !== cookie[data_name] && hidden !== null) {
              cookie[data_name] = hidden;
              cookie_changed = true;
            }
            myChart.data.datasets[i].data = graph_data.map(d => d[data_name]);
          }

          myChart.update();
          if (cookie_changed) {
            console.log("Changing cookie");
            localStorage.setItem('GraphShownLines', JSON.stringify(cookie));
          }
        }

      }
      setTimeout(chart_loop, 50);
    }

    // =======================================================
    // Main program
    // =======================================================
    loadAprilTags();
    await loadProjects();
    loadDirectories();

    // initial state: either start pre-filled for preview, or leave one empty picker
    const INIT_WITH_ALL = false; // enable to start with all projects pre-selected for layout preview
    if (INIT_WITH_ALL) initSelectAll();
    else ensureTrailingEmptyRow();

    disable_buttons();
    init("IQ2");
    connectBtn.addEventListener('click', connect);
    clearBtn.addEventListener('click', clearBoth);
    renameBtn.addEventListener('click', renameBrain);
    EventSystem.on("VEXBLEBrowser.EnterLockCode", EnterLockCode_callback);
    bleDeviceManager.notificationHandlerAIMTXUser = stdout_handler;

    canvasButton.addEventListener('click', showHideChart);
    overlay.addEventListener('click', showHideChart); // Clicking overlay hides chart
    snapBtn.addEventListener('click', toggleFreezeChart);
    snapBtn.style.display = "none";
    window.addEventListener('resize', resizeChart);
    window.projects = projects;
    chart_loop();
  </script>
</body>

</html>
